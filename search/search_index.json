{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAA Assignment 1 In this project we implement three algorithms for finding all the maximal cliques in an undirected graph in C++. The algorithms are: 1. The algorithm CLIQUE from pages 220-222 from the paper titled Arboricity and Subgraph Mining; by Norishige Chiba and Takao Nishizeki. (Link: https://www.cs.cornell.edu/courses/cs6241/2019sp/readings/Chiba-1985-arboricity.pdf). 2. The ELS Algorithm given in the paper titled Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time by David Eppstein, Maarten Loffler, and Darren Strash. (Link: https://arxiv.org/abs/1006.5440). 3. The algorithm given in the paper titled The worst-case time complexity for generating all maximal cliques and computational experiments by Etsuji Tomita, Akira Tanakaa, Haruhisa Takahashi. (Link: https://www.sciencedirect.com/science/article/pii/S0304397506003586). We then executed these algorithms on three graph datasets: 1. as-Skitter (Link: https://snap.stanford.edu/data/as-Skitter.html) 2. Email-Enron (Link: https://snap.stanford.edu/data/email-Enron.html) 3. Wiki-Vote (Link: https://snap.stanford.edu/data/wiki-Vote.html) We treated these datasets as undirected graphs and applied these algorithms. The input is taken from a text file with some optional text, including number of vertices, followed by edges, and the rest of the lines denoting a pair of vertices with an edge between them. We store the graphs in adjacency list format. The results are shown in the algorithm-wise markdowns, and the report. Github Repository: https://github.com/DarkTalisman20/DAA-Assignment-1 Webpage Link: https://darktalisman20.github.io/DAA-Assignment-1/ Contributions The various tasks and their contributions are given below: 1. Arboricity implementation: Abdul Rahman Yakoob, Saarthek Raj, Amritansh 2. ELS Implementation: Amritansh 3. Tomita Implementation: Paras Puneet Singh 4. Report: Chhavi Malhotra Run Locally 1.Download the zip file with codes from the submission. 2. Download the dataset zip folder from the google drive link. (Link: https://drive.google.com/drive/folders/16u1PDHzcSc9NJv8H8-DymsLPtUoBTNyt?usp=sharing ). 3. Extract the dataset .txt files from the zip folder and put them in the same folder where all the codes are. 4. Go to the project directory. 5. Compile the file and run it. For Unix/Mac: g++ <file-name>.cpp -o <file-name>.out ./<file-name>.out <dataset>.txt For Windows: g++ .cpp -o <file-name>.exe ./<file-name>.exe <dataset>.txt Example for ELS with Wiki-Vote we input: g++ els.cpp -o els.exe ./els.exe Wiki-Vote.txt file-name can be tomita, or els, or chiba. dataset can be wiki-Vote or as-skitter or email-Enron. Webpage Link: https://darktalisman20.github.io/DAA-Assignment-1/","title":"Home"},{"location":"#daa-assignment-1","text":"In this project we implement three algorithms for finding all the maximal cliques in an undirected graph in C++. The algorithms are: 1. The algorithm CLIQUE from pages 220-222 from the paper titled Arboricity and Subgraph Mining; by Norishige Chiba and Takao Nishizeki. (Link: https://www.cs.cornell.edu/courses/cs6241/2019sp/readings/Chiba-1985-arboricity.pdf). 2. The ELS Algorithm given in the paper titled Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time by David Eppstein, Maarten Loffler, and Darren Strash. (Link: https://arxiv.org/abs/1006.5440). 3. The algorithm given in the paper titled The worst-case time complexity for generating all maximal cliques and computational experiments by Etsuji Tomita, Akira Tanakaa, Haruhisa Takahashi. (Link: https://www.sciencedirect.com/science/article/pii/S0304397506003586). We then executed these algorithms on three graph datasets: 1. as-Skitter (Link: https://snap.stanford.edu/data/as-Skitter.html) 2. Email-Enron (Link: https://snap.stanford.edu/data/email-Enron.html) 3. Wiki-Vote (Link: https://snap.stanford.edu/data/wiki-Vote.html) We treated these datasets as undirected graphs and applied these algorithms. The input is taken from a text file with some optional text, including number of vertices, followed by edges, and the rest of the lines denoting a pair of vertices with an edge between them. We store the graphs in adjacency list format. The results are shown in the algorithm-wise markdowns, and the report. Github Repository: https://github.com/DarkTalisman20/DAA-Assignment-1 Webpage Link: https://darktalisman20.github.io/DAA-Assignment-1/","title":"DAA Assignment 1"},{"location":"#contributions","text":"The various tasks and their contributions are given below: 1. Arboricity implementation: Abdul Rahman Yakoob, Saarthek Raj, Amritansh 2. ELS Implementation: Amritansh 3. Tomita Implementation: Paras Puneet Singh 4. Report: Chhavi Malhotra","title":"Contributions"},{"location":"#run-locally","text":"1.Download the zip file with codes from the submission. 2. Download the dataset zip folder from the google drive link. (Link: https://drive.google.com/drive/folders/16u1PDHzcSc9NJv8H8-DymsLPtUoBTNyt?usp=sharing ). 3. Extract the dataset .txt files from the zip folder and put them in the same folder where all the codes are. 4. Go to the project directory. 5. Compile the file and run it. For Unix/Mac: g++ <file-name>.cpp -o <file-name>.out ./<file-name>.out <dataset>.txt For Windows: g++ .cpp -o <file-name>.exe ./<file-name>.exe <dataset>.txt Example for ELS with Wiki-Vote we input: g++ els.cpp -o els.exe ./els.exe Wiki-Vote.txt file-name can be tomita, or els, or chiba. dataset can be wiki-Vote or as-skitter or email-Enron. Webpage Link: https://darktalisman20.github.io/DAA-Assignment-1/","title":"Run Locally"},{"location":"Chiba-README/","text":"DAA-Assignment-1 An implementation of Arboricity algorithm We seek to implement the CLIQUE algorithm for Maximal Clique Enumeration Algorithm given in the paper Arboricity and Subgraph Listing by Norishige Chiba AND Takao Nishizeki. The algorithm CLIQUE enumerates all maximal cliques in a graph with a time complexity of O(\u03b1(G)m) per clique and O(m) space, where \u03b1(G) is the graph's arboricity (a sparsity measure which is defined as the number of edge-disjoint forests into which a graph can be decomposed) and m is the number of edges. The algorithm uses Tsukiyama et al's Maximal Independent set algorithm and the strategy of edge searching of subgraph induced by neighbours of vertex under consideration. In the algorithm above, \"maximality test\" checks whether the candidate of a new clique C\u2019 =(C \u2229 N(i))\u222a{i} is indeed a clique (i.e. maximal complete subgraph) of the graph Gi. The \"lexico. test\" checks whether C is the lexicographically largest clique of Gi-1 containing C \u2229 N(i), where i is argument of CLIQUE, and Gi is subgraph induced by vertices 1 to i and C is set of vertices to be expanded to form the clique. By leveraging vertex ordering (sorted by degree) and efficient pruning via lexicographical checks, the algorithm bounds per-clique operations to a cost proportional to the graph's density and edge count. The proof establishes this using inductive analysis, showing that the time for each recursive step UPDATE(i, C) is dominated by neighborhood intersections and degree sums, while space remains linear due to optimized global variables and disjoint set management. This approach balances theoretical optimality for sparse graphs (\u03b1(G) \u2248 O(1)) with practical scalability, though it retains exponential worst-case complexity for dense graphs. The method prioritizes low-degree vertices and early elimination of non-maximal cliques, ensuring efficient traversal of the search space. Run Locally Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Download the dataset and place it into the project directory/folder. Compile the file and run it. For Unix/Mac: g++ chiba.cpp -o chiba.out ./chiba.out <dataset>.txt For Windows: g++ chiba.cpp -o chiba.exe ./chiba.exe <dataset>.txt dataset can be wiki-Vote or as-skitter or email-Enron. 3. After the program executes properly you will get the following outputs on the terminal - \"code execution completed! results are available in output-chiba.txt of the same directory\" 4. Check the output-chiba.txt file to see the results of the execution. Note - For seeing results of next execution, please close and open the output-chiba.txt file again. Results The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. We executed the C++ implementation of ELS with 3 datasets: Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Since the algorithm took approximately 3.8 hours on Email-Enron and 57.35 minutes on Wiki-Vote, we estimate that it would take at least 50 hours on the as-skitter dataset, which contains 1,696,415 nodes and 11,095,298 edges. However, due to system constraints, we were unable to run the algorithm on as-skitter. Additionally, based on other algorithms, as-skitter has 37,322,355 cliques, with the largest maximal clique having a size of 67, which again shows that it would takes a lot of computational cost to give the output. For Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken: 7082330 ms (~1.9 hours) Number of cliques: 226859 Size of the largest maximal clique: 20 For Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken: 3441290 ms (~57.35 seconds) Total number of cliques: 459,002 Size of the largest maximal clique size: 17","title":"Chiba"},{"location":"Chiba-README/#daa-assignment-1","text":"","title":"DAA-Assignment-1"},{"location":"Chiba-README/#an-implementation-of-arboricity-algorithm","text":"We seek to implement the CLIQUE algorithm for Maximal Clique Enumeration Algorithm given in the paper Arboricity and Subgraph Listing by Norishige Chiba AND Takao Nishizeki. The algorithm CLIQUE enumerates all maximal cliques in a graph with a time complexity of O(\u03b1(G)m) per clique and O(m) space, where \u03b1(G) is the graph's arboricity (a sparsity measure which is defined as the number of edge-disjoint forests into which a graph can be decomposed) and m is the number of edges. The algorithm uses Tsukiyama et al's Maximal Independent set algorithm and the strategy of edge searching of subgraph induced by neighbours of vertex under consideration. In the algorithm above, \"maximality test\" checks whether the candidate of a new clique C\u2019 =(C \u2229 N(i))\u222a{i} is indeed a clique (i.e. maximal complete subgraph) of the graph Gi. The \"lexico. test\" checks whether C is the lexicographically largest clique of Gi-1 containing C \u2229 N(i), where i is argument of CLIQUE, and Gi is subgraph induced by vertices 1 to i and C is set of vertices to be expanded to form the clique. By leveraging vertex ordering (sorted by degree) and efficient pruning via lexicographical checks, the algorithm bounds per-clique operations to a cost proportional to the graph's density and edge count. The proof establishes this using inductive analysis, showing that the time for each recursive step UPDATE(i, C) is dominated by neighborhood intersections and degree sums, while space remains linear due to optimized global variables and disjoint set management. This approach balances theoretical optimality for sparse graphs (\u03b1(G) \u2248 O(1)) with practical scalability, though it retains exponential worst-case complexity for dense graphs. The method prioritizes low-degree vertices and early elimination of non-maximal cliques, ensuring efficient traversal of the search space.","title":"An implementation of Arboricity algorithm"},{"location":"Chiba-README/#run-locally","text":"Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Download the dataset and place it into the project directory/folder. Compile the file and run it. For Unix/Mac: g++ chiba.cpp -o chiba.out ./chiba.out <dataset>.txt For Windows: g++ chiba.cpp -o chiba.exe ./chiba.exe <dataset>.txt dataset can be wiki-Vote or as-skitter or email-Enron. 3. After the program executes properly you will get the following outputs on the terminal - \"code execution completed! results are available in output-chiba.txt of the same directory\" 4. Check the output-chiba.txt file to see the results of the execution. Note - For seeing results of next execution, please close and open the output-chiba.txt file again.","title":"Run Locally"},{"location":"Chiba-README/#results","text":"The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. We executed the C++ implementation of ELS with 3 datasets: Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Since the algorithm took approximately 3.8 hours on Email-Enron and 57.35 minutes on Wiki-Vote, we estimate that it would take at least 50 hours on the as-skitter dataset, which contains 1,696,415 nodes and 11,095,298 edges. However, due to system constraints, we were unable to run the algorithm on as-skitter. Additionally, based on other algorithms, as-skitter has 37,322,355 cliques, with the largest maximal clique having a size of 67, which again shows that it would takes a lot of computational cost to give the output. For Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken: 7082330 ms (~1.9 hours) Number of cliques: 226859 Size of the largest maximal clique: 20 For Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken: 3441290 ms (~57.35 seconds) Total number of cliques: 459,002 Size of the largest maximal clique size: 17","title":"Results"},{"location":"ELS-README/","text":"An Implementation of ELS Algorithm We seek to implement ELS algorithm given in the paper \"Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time\" by David Eppstein, Maarten Loffler, and Darren Stras from the Department of Computer Science, University of California, Irvine, USA. The language used in this implementation is C++, since we needed many STL containers and algorithms to implement the algorithm close to pseudo-code. The ELS is a variation of Bron-Kerbosch Algorithm. The ELS paper described time complexity in terms of degeneracy (d, which is the smallest number such that every sub-graph contains a node of degree atmost d), the complexity being O(dn(3^(d/3))). Bron-Kerbosch algorithm is a recursive algorithm which, as arguments take three disjoint sets of vertices, P (the set of vertices which will be considered for inclusion in the clique), R (the clique found so far), and X (the set of vertices which are excluded in maximal clique). The Bron-Kerbosch Algorithm recursion terminates when both P and X are empty, printing the maximal clique R. Else, the algorithm iterates over all the vertices v in P, recursively calling Bron-Kerbosch on arguments: P as P \u2229 neighbours(v), R as R \u222a{v} and X as X \u2229 neighbours(v). When the recursive call returns, we move v from P to X. The ELS modifies the Bron-Kerbosch Algorithm, in two basic ways. The first modification is to begin with a degeneracy ordering of vertices, which can be obtained by a greedy algorithm of selecting and then removing vertex with minimum degree till the graph is empty. Then, we iterate over all the vertices in the degeneracy ordering. The second modification is that for each vertex vi, we take the set P as all the neighbours of vi, which are after vi in degeneracy ordering, and X as all the neighbours of vi, which are before vi in degeneracy ordering, and R as {vi}. Here, instead of calling Bron-Kerbosch basic algorithm, we call a variation called Bron-Kerbosch Pivot, which has same arguments as Bron-Kerbosch with R = {vi}, but when P \u222a X is not empty, we choose a pivot in the same way as Tomita chose, that is the one with largest value of |P \u2229 neighbours (u)| from P \u222a X. After this, for each vertex v in P\\neighbours(u), we recursively call the Bron-Kerbosch Pivot with the arguments: P as P \u2229 neighbours(v), R as R \u222a{v} and X as X \u2229 neighbours(v). When the recursive call returns, we move v from P to X. Run Locally Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Compile the file and run it. For Unix/Mac: g++ els.cpp -o els.out ./els.out <dataset>.txt For Windows: g++ els.cpp -o els.exe ./els.exe <dataset>.txt dataset can be wiki-Vote or as-skitter or email-Enron. 3. After the program executes properly you will get the following outputs on the terminal - \"code execution completed! results are available in output-els.txt of the same directory\" 4. Check the output-els.txt file to see the results of the execution. Note - for seeing results of next execution, please close and open the output-els.txt file again. Results The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. We executed the C++ implementation of ELS on 3 datasets: Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Clique Size Count 2 2,319,807 3 3,171,609 4 1,823,321 5 939,336 6 684,873 7 598,284 8 588,889 9 608,937 10 665,661 11 728,098 12 798,073 13 877,282 14 945,194 15 980,831 16 939,987 17 839,330 18 729,601 19 639,413 20 600,192 21 611,976 22 640,890 23 673,924 24 706,753 25 753,633 26 818,353 27 892,719 28 955,212 29 999,860 30 1,034,106 31 1,055,653 32 1,017,560 33 946,717 34 878,552 35 809,485 36 744,634 37 663,650 38 583,922 39 520,239 40 474,301 41 420,796 42 367,879 43 321,829 44 275,995 45 222,461 46 158,352 47 99,522 48 62,437 49 39,822 50 30,011 51 25,637 52 17,707 53 9,514 54 3,737 55 2,042 56 1,080 57 546 58 449 59 447 60 405 61 283 62 242 63 146 64 84 65 49 66 22 67 4 Time taken: 3,410,914 ms (~56.85 minutes) Total number of cliques: 37,322,355 The size of the largest maximal clique: 67 For Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken: 5991 milliseconds (~6 seconds) Number of cliques: 226859 Size of the largest maximal clique: 20 For Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken: 6,133 ms (~6.13 seconds) Total number of cliques: 459,002 Size of the largest maximal clique size: 17","title":"ELS"},{"location":"ELS-README/#an-implementation-of-els-algorithm","text":"We seek to implement ELS algorithm given in the paper \"Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time\" by David Eppstein, Maarten Loffler, and Darren Stras from the Department of Computer Science, University of California, Irvine, USA. The language used in this implementation is C++, since we needed many STL containers and algorithms to implement the algorithm close to pseudo-code. The ELS is a variation of Bron-Kerbosch Algorithm. The ELS paper described time complexity in terms of degeneracy (d, which is the smallest number such that every sub-graph contains a node of degree atmost d), the complexity being O(dn(3^(d/3))). Bron-Kerbosch algorithm is a recursive algorithm which, as arguments take three disjoint sets of vertices, P (the set of vertices which will be considered for inclusion in the clique), R (the clique found so far), and X (the set of vertices which are excluded in maximal clique). The Bron-Kerbosch Algorithm recursion terminates when both P and X are empty, printing the maximal clique R. Else, the algorithm iterates over all the vertices v in P, recursively calling Bron-Kerbosch on arguments: P as P \u2229 neighbours(v), R as R \u222a{v} and X as X \u2229 neighbours(v). When the recursive call returns, we move v from P to X. The ELS modifies the Bron-Kerbosch Algorithm, in two basic ways. The first modification is to begin with a degeneracy ordering of vertices, which can be obtained by a greedy algorithm of selecting and then removing vertex with minimum degree till the graph is empty. Then, we iterate over all the vertices in the degeneracy ordering. The second modification is that for each vertex vi, we take the set P as all the neighbours of vi, which are after vi in degeneracy ordering, and X as all the neighbours of vi, which are before vi in degeneracy ordering, and R as {vi}. Here, instead of calling Bron-Kerbosch basic algorithm, we call a variation called Bron-Kerbosch Pivot, which has same arguments as Bron-Kerbosch with R = {vi}, but when P \u222a X is not empty, we choose a pivot in the same way as Tomita chose, that is the one with largest value of |P \u2229 neighbours (u)| from P \u222a X. After this, for each vertex v in P\\neighbours(u), we recursively call the Bron-Kerbosch Pivot with the arguments: P as P \u2229 neighbours(v), R as R \u222a{v} and X as X \u2229 neighbours(v). When the recursive call returns, we move v from P to X.","title":"An Implementation of ELS Algorithm"},{"location":"ELS-README/#run-locally","text":"Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Compile the file and run it. For Unix/Mac: g++ els.cpp -o els.out ./els.out <dataset>.txt For Windows: g++ els.cpp -o els.exe ./els.exe <dataset>.txt dataset can be wiki-Vote or as-skitter or email-Enron. 3. After the program executes properly you will get the following outputs on the terminal - \"code execution completed! results are available in output-els.txt of the same directory\" 4. Check the output-els.txt file to see the results of the execution. Note - for seeing results of next execution, please close and open the output-els.txt file again.","title":"Run Locally"},{"location":"ELS-README/#results","text":"The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. We executed the C++ implementation of ELS on 3 datasets: Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Clique Size Count 2 2,319,807 3 3,171,609 4 1,823,321 5 939,336 6 684,873 7 598,284 8 588,889 9 608,937 10 665,661 11 728,098 12 798,073 13 877,282 14 945,194 15 980,831 16 939,987 17 839,330 18 729,601 19 639,413 20 600,192 21 611,976 22 640,890 23 673,924 24 706,753 25 753,633 26 818,353 27 892,719 28 955,212 29 999,860 30 1,034,106 31 1,055,653 32 1,017,560 33 946,717 34 878,552 35 809,485 36 744,634 37 663,650 38 583,922 39 520,239 40 474,301 41 420,796 42 367,879 43 321,829 44 275,995 45 222,461 46 158,352 47 99,522 48 62,437 49 39,822 50 30,011 51 25,637 52 17,707 53 9,514 54 3,737 55 2,042 56 1,080 57 546 58 449 59 447 60 405 61 283 62 242 63 146 64 84 65 49 66 22 67 4 Time taken: 3,410,914 ms (~56.85 minutes) Total number of cliques: 37,322,355 The size of the largest maximal clique: 67 For Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken: 5991 milliseconds (~6 seconds) Number of cliques: 226859 Size of the largest maximal clique: 20 For Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken: 6,133 ms (~6.13 seconds) Total number of cliques: 459,002 Size of the largest maximal clique size: 17","title":"Results"},{"location":"Tomita-README/","text":"An Implementation of Tomita Algorithm We seek to implement the maximal clique enumeration algorithm based on Tomita et al.'s approach. The implementation uses C++ to closely mimic the pseudo-code described by Tomita and collaborators, leveraging STL containers and algorithms for efficiency. This algorithm is a refined variant of the Bron-Kerbosch recursive method, enhanced with a pivot selection strategy. In this method, three disjoint sets of vertices are maintained: - P : the set of candidate vertices for inclusion in the clique, - R : the clique constructed so far, and - X : the set of vertices that have already been processed (excluded from the current clique). The recursion terminates when both P and X are empty, at which point R represents a maximal clique. Otherwise, the algorithm selects a pivot vertex u from P \u222a X such that u has the largest number of neighbors in P . It then iterates over each vertex v in P that is not adjacent to u , and recursively calls the algorithm with updated sets: - P is replaced by P \u2229 neighbours(v) , - R is updated to R \u222a {v} , and - X becomes X \u2229 neighbours(v) . After the recursive call returns, v is removed from P and added to X . An early pruning strategy is also used: if the size of R plus the number of vertices in P is less than or equal to the size of the largest clique found so far, the recursion stops early, saving computational time. Run Locally Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Compile the file and run it. For Unix/Mac: g++ tomita.cpp -o tomita.out ./tomita.out <dataset>.txt For Windows: g++ tomita.cpp -o tomita.exe ./tomita.exe <dataset>.txt can be email-Enron or wiki-Vote or as-skitter. 3. The output shows the total number of nodes, maximum clique size, number of maximal cliques, their sizes and counts, and the execution time. Results The following results are based on executing the C++ implementation of the Tomita-based maximal clique algorithm on various datasets. The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. The output includes the number of maximal cliques found, the size of the largest clique, and the execution time. Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Clique Size Count 2 2,319,807 3 3,171,609 4 1,823,321 5 939,336 6 684,873 7 598,284 8 588,889 9 608,937 10 665,661 11 728,098 12 798,073 13 877,282 14 945,194 15 980,831 16 939,987 17 839,330 18 729,601 19 639,413 20 600,192 21 611,976 22 640,890 23 673,924 24 706,753 25 753,633 26 818,353 27 892,719 28 955,212 29 999,860 30 1,034,106 31 1,055,653 32 1,017,560 33 946,717 34 878,552 35 809,485 36 744,634 37 663,650 38 583,922 39 520,239 40 474,301 41 420,796 42 367,879 43 321,829 44 275,995 45 222,461 46 158,352 47 99,522 48 62,437 49 39,822 50 30,011 51 25,637 52 17,707 53 9,514 54 3,737 55 2,042 56 1,080 57 546 58 449 59 447 60 405 61 283 62 242 63 146 64 84 65 49 66 22 67 4 Time taken : Approximately 8 hours Total number of maximal cliques : 37,322,355 Size of the largest maximal clique : 67 Example results for Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken : 23 seconds Total number of maximal cliques : 226,859 Size of the largest maximal clique : 20 Example results for Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken : 4 seconds Total number of maximal cliques : 459,002 Size of the largest maximal clique : 17 ```","title":"Tomita"},{"location":"Tomita-README/#an-implementation-of-tomita-algorithm","text":"We seek to implement the maximal clique enumeration algorithm based on Tomita et al.'s approach. The implementation uses C++ to closely mimic the pseudo-code described by Tomita and collaborators, leveraging STL containers and algorithms for efficiency. This algorithm is a refined variant of the Bron-Kerbosch recursive method, enhanced with a pivot selection strategy. In this method, three disjoint sets of vertices are maintained: - P : the set of candidate vertices for inclusion in the clique, - R : the clique constructed so far, and - X : the set of vertices that have already been processed (excluded from the current clique). The recursion terminates when both P and X are empty, at which point R represents a maximal clique. Otherwise, the algorithm selects a pivot vertex u from P \u222a X such that u has the largest number of neighbors in P . It then iterates over each vertex v in P that is not adjacent to u , and recursively calls the algorithm with updated sets: - P is replaced by P \u2229 neighbours(v) , - R is updated to R \u222a {v} , and - X becomes X \u2229 neighbours(v) . After the recursive call returns, v is removed from P and added to X . An early pruning strategy is also used: if the size of R plus the number of vertices in P is less than or equal to the size of the largest clique found so far, the recursion stops early, saving computational time.","title":"An Implementation of Tomita Algorithm"},{"location":"Tomita-README/#run-locally","text":"Ensure that the .txt files of the datasets are in the same folder/directory as the code, and the terminal is also on the same folder/directory. Compile the file and run it. For Unix/Mac: g++ tomita.cpp -o tomita.out ./tomita.out <dataset>.txt For Windows: g++ tomita.cpp -o tomita.exe ./tomita.exe <dataset>.txt can be email-Enron or wiki-Vote or as-skitter. 3. The output shows the total number of nodes, maximum clique size, number of maximal cliques, their sizes and counts, and the execution time.","title":"Run Locally"},{"location":"Tomita-README/#results","text":"The following results are based on executing the C++ implementation of the Tomita-based maximal clique algorithm on various datasets. The code was executed on a Macbook Air 1, with 8 GB RAM and the execution time may differ for different devices. The output includes the number of maximal cliques found, the size of the largest clique, and the execution time. Dataset Nodes Edges as-skitter 1,696,415 11,095,298 Email-Enron 36,692 367,662 Wiki-Vote 7,115 103,689 We present the number and count of Maximal Cliques, Size of maximal clique and time taken to execute for these datasets. For as-skitter: Clique Size Count 2 2,319,807 3 3,171,609 4 1,823,321 5 939,336 6 684,873 7 598,284 8 588,889 9 608,937 10 665,661 11 728,098 12 798,073 13 877,282 14 945,194 15 980,831 16 939,987 17 839,330 18 729,601 19 639,413 20 600,192 21 611,976 22 640,890 23 673,924 24 706,753 25 753,633 26 818,353 27 892,719 28 955,212 29 999,860 30 1,034,106 31 1,055,653 32 1,017,560 33 946,717 34 878,552 35 809,485 36 744,634 37 663,650 38 583,922 39 520,239 40 474,301 41 420,796 42 367,879 43 321,829 44 275,995 45 222,461 46 158,352 47 99,522 48 62,437 49 39,822 50 30,011 51 25,637 52 17,707 53 9,514 54 3,737 55 2,042 56 1,080 57 546 58 449 59 447 60 405 61 283 62 242 63 146 64 84 65 49 66 22 67 4 Time taken : Approximately 8 hours Total number of maximal cliques : 37,322,355 Size of the largest maximal clique : 67 Example results for Email-Enron: Clique Size Count 2 14,070 3 7,077 4 13,319 5 18,143 6 22,715 7 25,896 8 24,766 9 22,884 10 21,393 11 17,833 12 15,181 13 11,487 14 7,417 15 3,157 16 1,178 17 286 18 41 19 10 20 6 Time taken : 23 seconds Total number of maximal cliques : 226,859 Size of the largest maximal clique : 20 Example results for Wiki-Vote: Clique Size Count 2 8,655 3 13,718 4 27,292 5 48,416 6 68,872 7 83,266 8 76,732 9 54,456 10 35,470 11 21,736 12 11,640 13 5,449 14 2,329 15 740 16 208 17 23 Time taken : 4 seconds Total number of maximal cliques : 459,002 Size of the largest maximal clique : 17 ```","title":"Results"}]}